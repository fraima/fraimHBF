Introduction
============

**Выбор инструмента**
---------

**Iptables**:
???Плюсы tip
    - Широко распространен и имеет долгую историю использования.
    - Обладает хорошей документацией и множеством ресурсов для обучения и отладки.
    - Мощный инструмент для управления трафиком с большим количеством опций и возможностей.
    - Хорошо поддерживается и имеет широкое сообщество пользователей.
    - Может быть использован вместе с другими инструментами, такими как fail2ban, для дополнительной защиты сервера.

???Минусы danger
    - Имеет сложный и запутанный синтаксис, что может быть проблематично для начинающих пользователей.
    - Не обеспечивает полностью декларативную конфигурацию, что может сделать отслеживание и управление правилами более сложным.
    - Некоторые функции, такие как обработка фрагментов пакетов, могут работать медленнее, чем в nftables.
    - Не поддерживает все возможности, которые доступны в nftables.

**eBPF**:
???Плюсы tip
    - Одним из главных преимуществ eBPF является высокая производительность и гибкость, которые достигаются за счет использования JIT-компиляции и возможности динамической загрузки и отключения программ. eBPF также обладает более широким набором инструментов для анализа сетевых пакетов и принятия решений на основе различных метрик, что может быть полезным в условиях высокой нагрузки и сложной сетевой инфраструктуры.
    - Гибкость: eBPF является универсальным инструментом, который может использоваться не только в качестве брандмауэра, но и для других задач, таких как мониторинг и анализ сетевого трафика.
    - Простота в использовании: eBPF имеет простой и понятный синтаксис, что делает его доступным для широкого круга пользователей.

???Минусы danger
    - Ограничения в возможностях: eBPF не поддерживает некоторые функции, которые могут быть полезны в качестве брандмауэра, такие как отслеживание состояния соединения.
    - Сложность настройки: eBPF требует определенного уровня знаний, что может сделать его настройку и использование более сложным для неопытных пользователей.

**nftables**:
???Плюсы tip 
    - Обладает более чистым и простым синтаксисом, чем iptables, что упрощает конфигурирование и отладку правил.
    - Предоставляет полностью декларативный подход к конфигурации брандмауэра.
    - Обрабатывает фрагменты пакетов быстрее, чем iptables.
    - Поддерживает множество функций, таких как отложенное применение правил и автоматическое управление временными правилами.
    - Есть поддержка динамического обновления правил без необходимости перезагрузки или пересборки целевого ядра. Это особенно полезно в случаях, когда требуется быстрое изменение конфигурации брандмауэра в реальном времени.
    - Есть поддержка групповых правил для более эффективного управления правилами, связанными с различными группами пакетов.
    - Есть поддержка более сложных типов матчей, которые могут использоваться для определения конкретных условий, таких как наличие конкретных флагов TCP или определенных значений IP-адресов.
    - Есть поддержка нативного синтаксиса для работы с IP-адресами и другими типами данных, что делает конфигурацию брандмауэра более простой и удобной.
    - Есть поддержка отслеживания состояния соединений, что позволяет создавать более сложные правила, основанные на состоянии соединения.
???Минусы danger
    - Относительно новый инструмент, и имеет меньшее сообщество пользователей и меньшее количество ресурсов для обучения и отладки, чем iptables.
    - Некоторые функции, такие как поддержка определенных модулей ядра, могут быть ограничены.
    - Не обладает всеми возможностями, которые доступны в iptables.

** Структура: **

???+ failure 
    - Те кто работают с K8S кластерами, видили как раздувается iptables в кол-ве правил из-за чего
    время обновления правил могли достигать минуты.

Т.к мы больше не обременены ограничениями iptables, мы можем создать отдельную таблицу и без опасения задеть чей-то chain, формируем требуемые структуры.

Кол-во правил мы смогли сократить благодаря простому подходу 5 tuple: 
>`srcIP`, `srcPORT`, `dstIP`, `dstPORT`, `protocol`  | verdict

где `srcIP`, `srcPORT`, `dstIP`, `dstPORT` являются IPSET массивами с rangeIP, rangePort.

Для группировки мы вводим такое понятие как SG=Security-Group.

???+ info
    SG - это своего рода логическая группа, которая включает в себя список подсетей от /32 до /0
    и обладает двумя атрибутами:

    - Owner
    - Subnets

???+ danger
    Главное условие - одна подсеть может находиться только в одной SG.
    
    >success:
    {"sg-1":
        "10.0.0.0/25"
    "sg-2":
        "10.0.0.128/25"}

    >failed:
    {"sg-1":
        "10.0.0.0/24"
    "sg-2":
        "10.0.0.128/25"}
    
    как видим 10.0.0.128/25 является частью подсети 10.0.0.0/24 

SG мы можем наполнять как нам угодно, в рамках какого-то процесса.
Например при создании виртуальной машины в cloud или onPrem, как только ей выделили IP адрес, мы можем добавить его в 
``SG-1 append 1.1.1.1/32 ``

???+ info
    - очередность ip адресов не важна, в рамках одной SG могут находиться подсети из разных подсетей (отдается на откуп ИБ и администраторов)
    - система будет стараться объединять соседние подсети в подсети высшего порядка, если есть такая возможность.

Таким образом у нас может появиться например две SG (SG-TEAM-A, SG-TEAM-B) с примером:

>Нужно организовать правило по которому 
SG-TEAM-A может ходить в SG-TEAM-B по порту 80,443

Для такого запроса, в nftables веделится 4 IPSET массива:
>`srcIP`, `srcPORT`, `dstIP`, `dstPORT`
которые заполнятся RangeIP, RangePorts согласно правилу.

Дальше остается только сформировать правило на (SG-TEAM-A, SG-TEAM-B) узлах.

Для SG-TEAM-A будет сформирована цепочка OUTPUT c правилом

`от SG-TEAM-A:IP SG-TEAM-A:PORT до SG-TEAM-B:IP SG-TEAM-B:PORT | protocol | accept`

Для SG-TEAM-B будет сформирована цепочка INPUT c правилом

`от SG-TEAM-A:IP SG-TEAM-A:PORT до SG-TEAM-B:IP SG-TEAM-B:PORT | protocol | accept`

Server
------
Сервер является ядром системы и позволяет клиентам забирать свою актуальную схему сетевых политик. 

Client
------
Клиент настраивает firewall узла, основываясь на IP адресах указанные на его интерфейсах и ответе от API,
в котором передается актуальный список правил, для каждой цепочки `INPUT`, `OUTPUT`, `FORWARD`.

``` mermaid
sequenceDiagram
    autonumber
    Client->>Netlink: есть че?
    Netlink->>Client: держи IP!
    loop Healthcheck
        Netlink->>Client: что-то обновилось
    end
    Client->>API: Кто я?
    API->>Client: Ты тварь дрожащая.
    Client->>API: А какие у меня права?
    API->>Client: Умеешь общаться с  TEAM-A
    Client->>API: Кто такие TEAM-A?
    API->>Client: Это четки пацаны!
    Client->>Nftables: Ну ок добавлю правило


```
